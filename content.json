{"meta":{"title":"辣鸡熊个人博客","subtitle":null,"description":null,"author":"辣鸡熊","url":"https://eeeje.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-11-18T11:16:11.335Z","updated":"2019-11-18T11:16:11.335Z","comments":false,"path":"/404.html","permalink":"https://eeeje.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2019-11-18T11:16:11.358Z","updated":"2019-11-18T11:16:11.358Z","comments":false,"path":"about/index.html","permalink":"https://eeeje.com/about/index.html","excerpt":"","text":"专注于自己钻研的IT初学者，主要从业与数通行业，爱好广泛，主要在web前端方向，没有系统学习过开发知识，总之很菜。"},{"title":"书单","date":"2019-11-18T11:16:11.531Z","updated":"2019-11-18T11:16:11.531Z","comments":false,"path":"books/index.html","permalink":"https://eeeje.com/books/index.html","excerpt":"","text":"douban: user: 趁与你 # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数"},{"title":"分类","date":"2019-11-18T11:16:11.651Z","updated":"2019-11-18T11:16:11.651Z","comments":false,"path":"categories/index.html","permalink":"https://eeeje.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-18T11:16:11.783Z","updated":"2019-11-18T11:16:11.783Z","comments":true,"path":"links/index.html","permalink":"https://eeeje.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-11-18T11:16:11.891Z","updated":"2019-11-18T11:16:11.891Z","comments":false,"path":"repository/index.html","permalink":"https://eeeje.com/repository/index.html","excerpt":"","text":"Githubgithub: username: lajix"},{"title":"标签","date":"2019-11-18T11:16:12.140Z","updated":"2019-11-18T11:16:12.140Z","comments":false,"path":"tags/index.html","permalink":"https://eeeje.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ICMP","slug":"ICMP","date":"2019-11-19T07:55:10.333Z","updated":"2019-11-19T07:55:10.333Z","comments":true,"path":"2019/11/19/ICMP/","link":"","permalink":"https://eeeje.com/2019/11/19/ICMP/","excerpt":"","text":"ICMP英特网控制消息协议 在网络设备间传递各种差错和控制信息 甲：你听到了吗？（ICMP Echo Request） 乙：听到了！（ICMP Echo Reply） ICMP中最重要的是类型（type）与代码（code） 类型 编码 描述 0 0 Echo Reply 3 0 网络不可达 3 1 主机不可达 3 2 协议不可达 3 3 端口不可达 5 0 重定向 8 0 Echo Request ping的用法12345678910111213141516171819202122232425262728293031用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] [-R] [-S srcaddr] [-c compartment] [-p] [-4] [-6] target_name选项: -t Ping 指定的主机，直到停止。 若要查看统计信息并继续操作，请键入 Ctrl+Break； 若要停止，请键入 Ctrl+C。 -a 将地址解析为主机名。 -n count 要发送的回显请求数。 -l size 发送缓冲区大小。 -f 在数据包中设置“不分段”标记(仅适用于 IPv4)。 -i TTL 生存时间。 -v TOS 服务类型(仅适用于 IPv4。该设置已被弃用， 对 IP 标头中的服务类型字段没有任何 影响)。 -r count 记录计数跃点的路由(仅适用于 IPv4)。 -s count 计数跃点的时间戳(仅适用于 IPv4)。 -j host-list 与主机列表一起使用的松散源路由(仅适用于 IPv4)。 -k host-list 与主机列表一起使用的严格源路由(仅适用于 IPv4)。 -w timeout 等待每次回复的超时时间(毫秒)。 -R 同样使用路由标头测试反向路由(仅适用于 IPv6)。 根据 RFC 5095，已弃用此路由标头。 如果使用此标头，某些系统可能丢弃 回显请求。 -S srcaddr 要使用的源地址。 -c compartment 路由隔离舱标识符。 -p Ping Hyper-V 网络虚拟化提供程序地址。 -4 强制使用 IPv4。 -6 强制使用 IPv6。 PING的错误类型正常状态（ping路由器上的网关）发送数据并受到回复 123456789101112[C:\\~]$ ping 192.168.123.1正在 Ping 192.168.123.1 具有 32 字节的数据:来自 192.168.123.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 192.168.123.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 192.168.123.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 192.168.123.1 的回复: 字节=32 时间&lt;1ms TTL=64192.168.123.1 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms 不可达/无法访问目标主机（ping一个不存在的地址）网关没有路由、找不到这个地址的mac地址，发不过去数据 12345678910[root@localhost ~]# ping 192.168.123.55PING 192.168.123.55 (192.168.123.55) 56(84) bytes of data.From 192.168.123.100 icmp_seq=1 Destination Host UnreachableFrom 192.168.123.100 icmp_seq=2 Destination Host UnreachableFrom 192.168.123.100 icmp_seq=3 Destination Host UnreachableFrom 192.168.123.100 icmp_seq=4 Destination Host Unreachable^C--- 192.168.123.55 ping statistics ---6 packets transmitted, 0 received, +4 errors, 100% packet loss, time 4999mspipe 4 超时这里我是ping我的旁路由（禁ping） 可以发数据过去，对方不回复（mac表中有对方地址） 一般为对方不在线或者屏蔽 12345678910[C:\\~]$ ping 192.168.1.1正在 Ping 192.168.1.1 具有 32 字节的数据:请求超时。请求超时。请求超时。请求超时。192.168.1.1 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 0，丢失 = 4 (100% 丢失)， 这里我发现一个其他的现象，我在使用linux来ping没有禁ping时的旁路由时 首先得到了一个1.39ms的回复 接着我的网关所在的路由告知了我一个新的下一跳 接下来的延迟都在0.3ms左右了 1234567891011121314[root@localhost ~]# ping 192.168.1.1PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=1.39 msFrom 192.168.123.1 icmp_seq=2 Redirect Host(New nexthop: 192.168.1.1)From 192.168.123.1: icmp_seq=2 Redirect Host(New nexthop: 192.168.1.1)64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=0.402 ms64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=0.371 ms64 bytes from 192.168.1.1: icmp_seq=4 ttl=64 time=0.319 ms64 bytes from 192.168.1.1: icmp_seq=5 ttl=64 time=0.303 ms64 bytes from 192.168.1.1: icmp_seq=6 ttl=64 time=0.346 ms^C--- 192.168.1.1 ping statistics ---6 packets transmitted, 6 received, +1 errors, 0% packet loss, time 5001msrtt min/avg/max/mdev = 0.303/0.523/1.399/0.393 ms","categories":[],"tags":[]},{"title":"ARP学习笔记","slug":"ARP","date":"2019-11-08T17:09:07.000Z","updated":"2019-11-18T11:16:12.492Z","comments":true,"path":"2019/11/09/ARP/","link":"","permalink":"https://eeeje.com/2019/11/09/ARP/","excerpt":"","text":"数据链路懒得没做笔记 ARP地址解析协议 通过目的IP来获取MAC地址的过程由ARP来实现 ARP原理前提，数据包中，源mac，源IP，目标IP都是已知的，那么，目标mac是怎么得来的呢 简单的说 小王：谁是小李，告诉小王 小李：小李在第一排第一个座位 这是我在局域网抓的包，科来软件可以直接看到，在我ping 192.168.123.1的时候他发送一个包，此时电脑网卡的mac缓存中并没有192.168.1.1的mac地址，所以他的目的地址为FF-FF-FF-FF-FF-FF(广播) 问：谁是192.168.123.1，告诉192.168.123.123（电脑的ip） 接着，路由器回复给电脑一个包，192.168.123.1在B0:25:AA:23:AB:74 (Private)，（前6位16进制数代表厂商） 这就是一个完整的arp，一次Request和一次Response 再用ensp来抓包看（stp disable关闭生成树） 在这里我发现了一个区别，在真机抓包时，以太网封装的目的地址为FF-FF-FF-FF-FF-FF但是arp协议中却是00-00-00-00-00-00F，模拟器中则都是FF-FF-FF-FF-FF-FF 总结： 发送 源ip 源mac 目标ip 目标ip 相应 源ip 源mac 目标ip 目标ip 拓展 MAC地址扫描器的原理就是发出很多个arp的包，挨个去问。 ARP缓存 ARP欺骗更改源MAC达到“欺骗”的效果 情景：主机3修改为和主机2相同的ip，主机1在进行发包时会向最新收到的Response报文中的mac地址发送 主机1：谁是1.1.1.2 主机2：1.1.1.2在a地址（真实） 主机3：1.1.1.2在b地址（欺骗） 主机1将1.1.1.2的包发往b地址 实践 使用工具抓到网关回给我的包，修改arp中的源mac地址，再发送广播报文进行arp欺骗 下面可以看到我的电脑arp缓存中的mac已经变为了11:22:33:44:55:66抓包软件也是抓到了我不停发送的包。 防范主机上的防范，通过软件绑定网关的ip与mac，保护这台电脑不被“欺骗” 交换机：拥有很完善的一套防范设施。（np安全） 免费ARP免费()ARP可以检测出ip地址是否冲突 更改ip以后，电脑会先询问网络中有没有人使用这个ip，如果没有回复，则使用这个ip 当这个ip有人使用时，证明地址冲突，电脑则会自动配置一个无效的地址 总结ARP报文不能穿越路由器，不能转发到其他广播域","categories":[{"name":"路由交换","slug":"路由交换","permalink":"https://eeeje.com/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://eeeje.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"11.5笔记","slug":"11.5","date":"2019-11-05T11:05:44.000Z","updated":"2019-11-18T11:16:12.365Z","comments":true,"path":"2019/11/05/11.5/","link":"","permalink":"https://eeeje.com/2019/11/05/11.5/","excerpt":"","text":"vlan路由器分割广播域 跨vlan通信 单臂路由 子接口 SVI口 问题： acess trunk hybrid 什么时候打tag 什么时候剥离tag的问题？","categories":[{"name":"路由交换","slug":"路由交换","permalink":"https://eeeje.com/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://eeeje.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"1103 OSPF笔记","slug":"1103","date":"2019-11-03T11:05:44.000Z","updated":"2019-11-18T11:16:12.477Z","comments":true,"path":"2019/11/03/1103/","link":"","permalink":"https://eeeje.com/2019/11/03/1103/","excerpt":"","text":"ospf基础RIP是一个矢量距离路由协议 OSPF区域内靠SPF算法保证无路由环路 区域间依靠 区域间的链接规则 骨干区域 area0区域 非骨干区域围绕骨干区域星型拓扑 推荐《数据结构》 三个路由器 每个都启用ospf 同区域 lsa （链路状态信息，链路状态通告）：接口信息等 互相 flooding（泛洪）有平衡点 每台都有一个lsdb 链路数据库 三份数据库 每一个都去通过spf计算从自己出发的最短路径 画出一个有向图（树状图-无环路） OSPF报文5种报文 hello报文 dd 报文 lsr 报文 lsu报文 lsack报文 报文头相同 但凡是协议，都有状态机 路由交换 安全 wlan 邻居状态机 （？？？） Router ID是一个32位的值 2-way到ExStart是选DR MA网络广播 路由之间连接属于ma无论几个相连 DR和BDR的好处是什么？ 先选BDR再选DR","categories":[{"name":"路由交换","slug":"路由交换","permalink":"https://eeeje.com/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://eeeje.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"华为设备OSPF路由的配置","slug":"OSPF","date":"2019-11-02T17:44:10.000Z","updated":"2019-11-18T11:16:12.879Z","comments":true,"path":"2019/11/03/OSPF/","link":"","permalink":"https://eeeje.com/2019/11/03/OSPF/","excerpt":"","text":"实验中有很多个人的理解，因为基础较差，难免会有一些错误的地方，如果您有建议或理解，欢迎在文章下方留言😁 文章较长，下方浮动栏有文章目录按钮哟😃 OSPFOpen Shortest Path First翻译过来是开放式最短路径优先 华为设备中OSPF的优先级是 10 仅低于直连路由 OSPF单区域配置实验设备HUAWEI AR2220 PC 实验拓扑&amp;规划我并没有使用实验指导中提供的IP规划 实验目的通过配置单个OSPF区域的配置，使PC1、PC2、PC2所在网络互通 实验过程 为各接口以及PC配置IP，并确保每一对接口之间连通。 为路由器配置OSPF 1[R1]ospf 1 //1为进程号 进入骨干区域 1[R1-ospf-1]area 0 接下来就可以来指定运行OSPF协议的接口和接口所属的区域 123[R1-ospf-1-area-0.0.0.0]network 172.10.1.0 0.0.0.255[R1-ospf-1-area-0.0.0.0]network 10.0.0.0 0.0.0.3[R1-ospf-1-area-0.0.0.0]network 10.0.0.4 0.0.0.3 Q：这里的命令我不太理解猜测后面的应该为255减去原来的掩码位（数通基础不好） 检查通告情况，命令：display ospf interface 12345678 OSPF Process 1 with Router ID 172.10.1.254 Interfaces Area: 0.0.0.0 (MPLS TE not enabled)IP Address Type tate Cost Pri DR BDR 172.10.1.254 Broadcast DR 1 1 172.10.1.254 0.0.0.010.0.0.2 Broadcast DR 1 1 10.0.0.2 0.0.0.010.0.0.6 Broadcast DR 1 1 10.0.0.6 0.0.0.0 这里可以看到area域为0.0.0.0，RoutID为172.10.1.254 ，另外可以看待通告出去三个接口的类型为广播，接口状态为DR，即都是所在网络中的指定路由器。拓展：DR ：一个广播性、多接入网络中的指定路由器，个人理解为一个网络中的“管事的”Q：为什么会选这个ip做为RoutID？ 配置R2 R3 1234567891011[R2]ospf 1[R2-ospf-1]area 0[R2-ospf-1-area-0.0.0.0]network 10.0.0.1 0.0.0.3[R2-ospf-1-area-0.0.0.0]network 10.0.0.9 0.0.0.3[R2-ospf-1-area-0.0.0.0]network 172.10.2.254 0.0.0.255[R3]ospf 1[R3-ospf-1]area 0[R3-ospf-1-area-0.0.0.0]network 10.0.0.5 0.0.0.3[R3-ospf-1-area-0.0.0.0]network 10.0.0.10 0.0.0.3[R3-ospf-1-area-0.0.0.0]network 172.10.3.1 0.0.0.255 这里我配置完以后发现，命令敲错了，network 后面的直接输了接口地址，但是我去查通告情况，看起来是正常的，我觉得，后面的那个字段和掩码有关，掩码是用来定义网络的，所以说我输入的32位的地址被定义为了当前ip所在的网络，暂且不去管他。 检查OSPF邻居display ospf peer 12345678910111213141516171819202122OSPF Process 1 with Router ID 172.10.1.254 NeighborsArea 0.0.0.0 interface 10.0.0.2(GigabitEthernet0/0/0)&apos;s neighborsRouter ID: 172.10.2.254 Address: 10.0.0.1 State: Full Mode:Nbr is Master Priority: 1 DR: 10.0.0.2 BDR: 10.0.0.1 MTU: 0 Dead timer due in 39 sec Retrans timer interval: 5 Neighbor is up for 00:35:24 Authentication Sequence: [ 0 ] Neighbors Area 0.0.0.0 interface 10.0.0.6(GigabitEthernet0/0/2)&apos;s neighborsRouter ID: 10.0.0.10 Address: 10.0.0.5 State: Full Mode:Nbr is Slave Priority: 1 DR: 10.0.0.6 BDR: 10.0.0.5 MTU: 0 Dead timer due in 29 sec Retrans timer interval: 5 Neighbor is up for 00:28:32 Authentication Sequence: [ 0 ] 这里看到了两个OSPF邻居RoutID分别为：172.10.1.254，10.0.0.10（这个RoutID用了路由之间的接口ID） 猜测：RoutID的原则是不重复，所以说是不是随便指定一个ip做为RoutID实验：我新开了一台路由器去尝试，发现 RoutID的选择是根据第一个配置的接口ip进行选择的。我回头去看R3的数据，我第一个配置的接口Ip的确是1.0.0.10/30 现在再去查通告情况，看一下前面看不懂的DR 12345678 OSPF Process 1 with Router ID 172.10.1.254 Interfaces Area: 0.0.0.0 (MPLS TE not enabled)IP Address Type State Cost Pri DR BDR 172.10.1.254 Broadcast DR 1 1 172.10.1.254 0.0.0.010.0.0.2 Broadcast DR 1 1 10.0.0.2 10.0.0.110.0.0.6 Broadcast DR 1 1 10.0.0.6 10.0.0.5 DR是指定路由器，BDR是备份指定路由器，既然前面说到了DR是管事的那BDR就是副管事的，当管事的不在或者做错的时候，副管事的就出来接手，这两个管事的又是由大家选出来的，这里就涉及到OSPF的选举机制了，由于理论部分还没有学到这里，暂时放一下。 现在从表中看出，172.1.1.254是自己所在网络的DR，他的BDR是一个缺省状态，另外两个网络的BDR都是自己网络中存在于OSPF域中的地址 再看看OSPF的路由表 Public routing table : OSPF Destinations : 3 Routes : 4 OSPF routing table status : &lt;Active&gt; Destinations : 3 Routes : 4 Destination/Mask Proto Pre Cost Flags NextHop Interface 10.0.0.8/30 OSPF 10 2 D 10.0.0.1 GigabitEthernet 0/0/0 OSPF 10 2 D 10.0.0.5 GigabitEthernet 0/0/2 172.10.2.0/24 OSPF 10 2 D 10.0.0.1 GigabitEthernet 0/0/0 172.10.3.0/24 OSPF 10 2 D 10.0.0.5 GigabitEthernet 0/0/2 OSPF routing table status : &lt;Inactive&gt; Destinations : 0 Routes : 0实验验证 由PC1ping PC2 PC&gt;ping 172.10.2.1 Ping 172.10.2.1: 32 data bytes, Press Ctrl_C to break Request timeout! From 172.10.2.1: bytes=32 seq=2 ttl=126 time=16 ms From 172.10.2.1: bytes=32 seq=3 ttl=126 time=15 ms From 172.10.2.1: bytes=32 seq=4 ttl=126 time=16 ms From 172.10.2.1: bytes=32 seq=5 ttl=126 time=16 ms --- 172.10.2.1 ping statistics --- 5 packet(s) transmitted 4 packet(s) received 20.00% packet loss round-trip min/avg/max = 0/15/16 ms单区域的实验结束 OSPF多区域配置在网络规模很大的时候，就要分为多个自治域去管理，否则每个路由上的链路状态数据库将会非常的巨大，这就考虑到了路由器的硬件因素，打个简单的比方，大家都知道π=3.141592653…但是这个值不需要我们每次使用的时候都拿去算，因为已经有人算好了，拿来用就好了，多区域就是不同as域的计算、选举，都是独立的，由边界路由提供区域间的联系。 关于链路数据库大小的概念，这里拿一台来自俄勒冈大学全球BGP路由表浏览项目的路由器打个比方（好像关系不大🤔）这是一台思科的设备，使用的BGP路由他的路由表是一个很庞大的数量使用的内存也达到了8.5G左右 而我们实验中用到的AR2220的内存仅有1G好像ospf多域解决的是计算等问题，而且ospf和bgp的机制也有很大不同😓，上面这部分就当个拓展，另外在百度的时候发现了一段有意思的话： OSPF：“身如路由器，心似转发表，报文何其多，日夜勤查找。”BGP：“路由本非器，转发何需表？报文虽然多，自有他人找。” 先收藏起来 言归正传 实验拓扑&amp;规划基于上一部分是实验进行改动其中R1 R2 R3 R4 在区域 0 中，R1 R2 R5在区域 1 中，R3 R4 R6 在区域 2 中 实验目的R1 R2 R3 R4 为核心区域，在同一个as域中，其中R1 R2 与 R5 同在区域 1 中，R3 R4 与 R5 同在区域 2 中从本质上来讲，可以理解为“分布式计算”，区域1计算出a=1，区域2计算出b=2，区域3计算出c=3,甲在区域1和2中，乙在区域2和3中，甲和乙互相沟通后，大家都知道a,b,c的值了。 实验过程 配置各接口IP 配置骨干区域，将R1 R2 R3 R4 配入area 0 中，并互相通告 配置区域A 即R1 R2 R5 配入 area 1 中，其中R1 R2只通告与R5相连的接口 配置区域B 即R3 R4 R6 配入 area 2 中，其中R3 R4只通告与R6相连的接口 邻区没有问题 查一下OSPF链路状态数据库 1234567891011121314151617181920212223242526272829[Huawei]display ospf lsdbOSPF Process 1 with Router ID 10.0.0.18 Link State Database Area: 0.0.0.2 Type LinkState ID AdvRouter Age Len Sequence MetricRouter 10.0.0.14 10.0.0.14 411 36 80000005 1Router 172.10.3.254 172.10.3.254 421 36 80000005 1Router 10.0.0.18 10.0.0.18 409 60 80000008 1Network 10.0.0.17 10.0.0.14 411 32 80000002 0Network 10.0.0.22 172.10.3.254 421 32 80000002 0Sum-Net 172.10.3.0 172.10.3.254 615 28 80000001 1Sum-Net 172.10.3.0 10.0.0.14 560 28 80000001 2Sum-Net 172.10.2.0 172.10.3.254 615 28 80000001 2Sum-Net 172.10.2.0 10.0.0.14 560 28 80000001 3Sum-Net 172.10.1.0 172.10.3.254 615 28 80000001 3Sum-Net 172.10.1.0 10.0.0.14 560 28 80000001 3Sum-Net 10.0.0.12 172.10.3.254 615 28 80000001 2Sum-Net 10.0.0.12 10.0.0.14 560 28 80000001 1Sum-Net 10.0.0.8 172.10.3.254 615 28 80000001 1Sum-Net 10.0.0.8 10.0.0.14 560 28 80000001 2Sum-Net 10.0.0.4 172.10.3.254 615 28 80000001 1Sum-Net 10.0.0.4 10.0.0.14 560 28 80000001 1Sum-Net 10.0.0.0 172.10.3.254 615 28 80000001 2Sum-Net 10.0.0.0 10.0.0.14 560 28 80000001 2Sum-Net 10.0.0.28 172.10.3.254 615 28 80000001 2Sum-Net 10.0.0.28 10.0.0.14 560 28 80000001 3Sum-Net 10.0.0.24 172.10.3.254 615 28 80000001 3Sum-Net 10.0.0.24 10.0.0.14 560 28 80000001 2 除了我们通告的路由之外，其他的路由都是Sum-Net类型的我去搜Sum-Net是什么，并没有搜到，但是发现启示录中有一条Sum-Net LSA会引起路由计算，引发OSPF路由震荡 实验验证PC1 ping PC4 PC&gt;ping 172.10.4.1 Ping 172.10.4.1: 32 data bytes, Press Ctrl_C to break From 172.10.1.1: Destination host unreachable失败 排障 先用PC1与PC4 ping各自的网关 –成功查看R5 R6路由表 –有对应条目检查电脑配置 –未配置网关 PC&gt;ping 172.10.4.1 Ping 172.10.4.1: 32 data bytes, Press Ctrl_C to break Request timeout! From 172.10.4.1: bytes=32 seq=2 ttl=124 time=31 ms From 172.10.4.1: bytes=32 seq=3 ttl=124 time=31 ms From 172.10.4.1: bytes=32 seq=4 ttl=124 time=31 ms From 172.10.4.1: bytes=32 seq=5 ttl=124 time=32 ms --- 172.10.4.1 ping statistics --- 5 packet(s) transmitted 4 packet(s) received 20.00% packet loss round-trip min/avg/max = 0/31/32 ms实验完成 OSPF的认证“对暗号” 我理解为防止非法路由加入网络中 实验拓扑/规划 R1的loopback的地址是1.1.1.1 ，R2的是2.2.2.2，以此类推 实验目的在区域0和1配上区域认证，0开启密文认证，1开启明文认证 实验过程OSPF区域认证 配置各接口IP，并配置loopback地址 将R2 R3 R5 R6 配入area 0 中，并通告网络，将R1 R2 R4 配入area 1 中，同样通告网络 需要注意的是，每台设备都需要把loopback地址通告出去 配置区域 可以看到R2有了正确的邻居关系 给区域1配置区域认证 R1 1234567891011121314151617[Huawei]ospf 1[Huawei-ospf-1]ar [Huawei-ospf-1]area 1[Huawei-ospf-1-area-0.0.0.1]au [Huawei-ospf-1-area-0.0.0.1]authentication-mode s [Huawei-ospf-1-area-0.0.0.1]authentication-mode simple p [Huawei-ospf-1-area-0.0.0.1]authentication-mode simple plain huawei1[Huawei-ospf-1-area-0.0.0.1]disp [Huawei-ospf-1-area-0.0.0.1]display th[V200R003C00]# area 0.0.0.1 authentication-mode simple plain huawei1 network 1.1.1.1 0.0.0.0 network 10.0.0.0 0.0.0.3 #return 这时候可以看到口令为huawei1 重新配置一遍 发现个有趣的东西，按上键的时候，原来输入的口令会变成****** 现在口令变为了密文显示 12345678910[Huawei-ospf-1-area-0.0.0.1]authentication-mode simple huawei1[Huawei-ospf-1-area-0.0.0.1]display th[V200R003C00]# area 0.0.0.1 authentication-mode simple cipher %$%$6iLJ4J=YgV@LW7RZhQgXRp_4%$%$ network 1.1.1.1 0.0.0.0 network 10.0.0.0 0.0.0.3 #return R2也没有了R1的邻居关系 123456789&lt;R2&gt;display ospf 1 peer brief OSPF Process 1 with Router ID 10.0.0.2 Peer Statistic Information ---------------------------------------------------------------------------- Area Id Interface Neighbor id State 0.0.0.0 GigabitEthernet0/0/1 10.0.0.6 Full 0.0.0.1 GigabitEthernet0/0/2 4.4.4.4 Full ---------------------------------------------------------------------------- 接下来配R2 R4的认证 12345678910111213141516[R2]ospf 1[R2-ospf-1]area 1 [R2-ospf-1-area-0.0.0.1]au [R2-ospf-1-area-0.0.0.1]authentication-mode s [R2-ospf-1-area-0.0.0.1]authentication-mode simple p [R2-ospf-1-area-0.0.0.1]authentication-mode simple plain huawei1[R2-ospf-1-area-0.0.0.1]authentication-mode simple huawei1[R2-ospf-1-area-0.0.0.1]display ospf 1 peer brief OSPF Process 1 with Router ID 10.0.0.2 Peer Statistic Information ---------------------------------------------------------------------------- Area Id Interface Neighbor id State 0.0.0.0 GigabitEthernet0/0/1 10.0.0.6 Full 0.0.0.1 GigabitEthernet0/0/0 10.0.0.1 Full ---------------------------------------------------------------------------- 可以看到现在R2与R1的邻居关系恢复了，没有了R4的邻居，接着去配R4 123456789[R4-ospf-1-area-0.0.0.1]display th[V200R003C00]# area 0.0.0.1 authentication-mode simple cipher %$%$tuiTSpt&apos;-/`8ey(B&#125;PlFR&amp;~y%$%$ network 4.4.4.4 0.0.0.0 network 10.0.0.16 0.0.0.3 #return R2的邻居关系也正常了 12345678910&lt;R2&gt;display ospf 1 peer brief OSPF Process 1 with Router ID 10.0.0.2 Peer Statistic Information ---------------------------------------------------------------------------- Area Id Interface Neighbor id State 0.0.0.0 GigabitEthernet0/0/1 10.0.0.6 Full 0.0.0.1 GigabitEthernet0/0/2 4.4.4.4 Full 0.0.0.1 GigabitEthernet0/0/0 10.0.0.1 Full ---------------------------------------------------------------------------- OSPF链路验证 在R2与R4之间部署MD5的链路认证 1[R2-GigabitEthernet0/0/2]ospf authentication-mode md5 1 huawei5 去看邻居信息 123456789&lt;R2&gt;display ospf 1 peer brief OSPF Process 1 with Router ID 10.0.0.2 Peer Statistic Information---------------------------------------------------------------------------- Area Id Interface Neighbor id State 0.0.0.0 GigabitEthernet0/0/1 10.0.0.6 Full 0.0.0.1 GigabitEthernet0/0/0 10.0.0.1 Full ---------------------------------------------------------------------------- 现在与R4的邻居没有了，因为R2与R4连接的接口被配上了链路认证 给R4也配上链路认证 12345678 OSPF Process 1 with Router ID 10.0.0.2 Peer Statistic Information---------------------------------------------------------------------------- Area Id Interface Neighbor id State 0.0.0.0 GigabitEthernet0/0/1 10.0.0.6 Full 0.0.0.1 GigabitEthernet0/0/2 4.4.4.4 Full 0.0.0.1 GigabitEthernet0/0/0 10.0.0.1 Full ---------------------------------------------------------------------------- R2的与R4的邻居重新建立 OSPF被动接口配置让一个接口从“参与者”变为“使用者” 拓扑&amp;规划 实验过程 配置接口ip，并且都放入area 0 中 对PC上的接口进行抓包，可以看到有很多OSPF的hello packet报文，报文中包含了本area中的信息 所以需要配置被动接口，禁止连接终端的接口接收发送OSPF报文 将与终端相连的接口配置为被动接口 12345678910111213[R4]ospf 1[R4-ospf-1]sil [R4-ospf-1]silent-interface g 0/0/2 [R4-ospf-1]display th[V200R003C00]#ospf 1 silent-interface GigabitEthernet0/0/2 area 0.0.0.0 network 10.0.0.16 0.0.0.7 network 10.1.1.0 0.0.0.255 #return 重新去抓包，就不会再发现有来自OSPF的报文了 实验结论既然被动接口会使当前接口不再发送和接收OSPF的报文，所以不可以配置在路由之间的接口上，否则会使当前接口退出OSPF OSPF的Router-ID其实关于Router-ID，我之前就做了简单的验证，当时得出的结论是： 猜测：RoutID的原则是不重复，所以说是不是随便指定一个ip做为RoutID实验：我新开了一台路由器去尝试，发现 RoutID的选择是根据第一个配置的接口ip进行选择的。我回头去看R3的数据，我第一个配置的接口Ip的确是1.0.0.10/30 完善下Router ID的选举规则 在没有手动配置Router-ID的情况下，第一个配置的接口IP，会被指定为Router-ID，如果这个IP被删除，如果当前有loopback地址，则Router-ID会被指定为loopback地址，如果没有，则会被指定为第二个配置的Router-ID，以此类推。 123456789101112131415161718192021[Huawei]int [Huawei]interface g 0/0/0[Huawei-GigabitEthernet0/0/0]ip add 1.1.1.1 24[Huawei-GigabitEthernet0/0/0]interface g 0/0/1[Huawei-GigabitEthernet0/0/1]ip add 2.2.2.2 24[Huawei-GigabitEthernet0/0/1]disp [Huawei-GigabitEthernet0/0/1]display r [Huawei-GigabitEthernet0/0/1]display ro [Huawei-GigabitEthernet0/0/1]display route idRouterID:1.1.1.1 //此时的RouterID为第一个配置的接口IP[Huawei-GigabitEthernet0/0/1]interface g 0/0/0[Huawei-GigabitEthernet0/0/0]undo ip add[Huawei-GigabitEthernet0/0/0]display route idRouterID:2.2.2.2 //删除第一个配置的接口IP后，被指定为第二个接口IP[Huawei-GigabitEthernet0/0/0]ip add 1.1.1.1 24[Huawei-GigabitEthernet0/0/0]interface l 0[Huawei-LoopBack0]ip add 6.6.6.6 32[Huawei-LoopBack0]interface g 0/0/1[Huawei-GigabitEthernet0/0/1]undo ip ad[Huawei-GigabitEthernet0/0/1]display route idRouterID:6.6.6.6 //这时就会被指定为loopback地址 如果RouterID重复，会发生什么？ 简单拓扑 配置相同的RouterID 修改完RouterID后，会有这样的提醒：路由器ID已修改，请手动重置相关协议更新路由器ID 现在去查看邻居 1234567891011 OSPF Process 1 with Router ID 1.1.1.1 Neighbors Area 0.0.0.0 interface 1.1.1.1(GigabitEthernet0/0/0)&apos;s neighborsRouter ID: 1.1.1.2 Address: 1.1.1.2 State: Full Mode:Nbr is Master Priority: 1 DR: 1.1.1.1 BDR: 1.1.1.2 MTU: 0 Dead timer due in 40 sec Retrans timer interval: 5 Neighbor is up for 00:08:51 Authentication Sequence: [ 0 ] Router ID还是原来的，结合之前的提醒，需要重置一下协议：reset ospf process（这个命令只可以在用户界面使用） 再去看邻居 123&lt;Huawei&gt;display ospf peer OSPF Process 1 with Router ID 6.6.6.6 没有邻居了，那么路由自然也不会通告 再看一下不同区域的相同RouterID 两侧的路由拥有相同的RouterID 1234567891011121314151617181920212223242526[Huawei]display ospf lsdb OSPF Process 1 with Router ID 6.6.6.6 Link State Database Area: 0.0.0.0 Type LinkState ID AdvRouter Age Len Sequence Metric Router 6.6.6.7 6.6.6.7 425 36 80000004 1 Router 6.6.6.6 6.6.6.6 592 36 80000007 1 Router 1.1.1.2 1.1.1.2 788 36 80000008 1 Router 1.1.1.1 1.1.1.1 1512 36 80000005 1 Network 1.1.1.1 6.6.6.6 592 32 80000002 0 Sum-Net 1.1.2.0 6.6.6.7 371 28 80000001 1[Huawei]ping 1.1.2.2 PING 1.1.2.2: 56 data bytes, press CTRL_C to break Reply from 1.1.2.2: bytes=56 Sequence=1 ttl=254 time=30 ms Reply from 1.1.2.2: bytes=56 Sequence=2 ttl=254 time=20 ms Reply from 1.1.2.2: bytes=56 Sequence=3 ttl=254 time=30 ms Reply from 1.1.2.2: bytes=56 Sequence=4 ttl=254 time=30 ms Reply from 1.1.2.2: bytes=56 Sequence=5 ttl=254 time=30 ms --- 1.1.2.2 ping statistics --- 5 packet(s) transmitted 5 packet(s) received 0.00% packet loss round-trip min/avg/max = 20/28/30 ms 可以看出来，并没有对网络造成影响。 所以，RouterID在同区域内重叠是会影响ospf状态的，不同区域则不会 DR与BDR12345678910&lt;R1&gt;display ospf peer b OSPF Process 1 with Router ID 1.1.1.1 Peer Statistic Information---------------------------------------------------------------------------- Area Id Interface Neighbor id State 0.0.0.0 GigabitEthernet0/0/0 2.2.2.2 2-Way 0.0.0.0 GigabitEthernet0/0/0 3.3.3.3 Full 0.0.0.0 GigabitEthernet0/0/0 4.4.4.4 Full ---------------------------------------------------------------------------- 1234567891011121314151617181920212223242526272829&lt;R1&gt;display ospf peer OSPF Process 1 with Router ID 1.1.1.1 Neighbors Area 0.0.0.0 interface 192.168.1.1(GigabitEthernet0/0/0)&apos;s neighbors Router ID: 2.2.2.2 Address: 192.168.1.2 State: 2-Way Mode:Nbr is Master Priority: 1 DR: 192.168.1.3 BDR: 192.168.1.4 MTU: 0 Dead timer due in 37 sec Retrans timer interval: 0 Neighbor is up for 00:00:00 Authentication Sequence: [ 0 ] Router ID: 3.3.3.3 Address: 192.168.1.3 State: Full Mode:Nbr is Master Priority: 1 DR: 192.168.1.3 BDR: 192.168.1.4 MTU: 0 Dead timer due in 30 sec Retrans timer interval: 5 Neighbor is up for 00:02:26 Authentication Sequence: [ 0 ] Router ID: 4.4.4.4 Address: 192.168.1.4 State: Full Mode:Nbr is Master Priority: 1 DR: 192.168.1.3 BDR: 192.168.1.4 MTU: 0 Dead timer due in 32 sec Retrans timer interval: 5 Neighbor is up for 00:02:25 Authentication Sequence: [ 0 ] 此时R3为DR，R4为BDR 接着修改OSPF的网络类型为点到多点 1ospf network-type p2mp 此时可以看到，DR和BDR都是none 1234567891011121314151617181920212223242526272829&lt;R1&gt;display ospf peer OSPF Process 1 with Router ID 1.1.1.1 Neighbors Area 0.0.0.0 interface 192.168.1.1(GigabitEthernet0/0/0)&apos;s neighbors Router ID: 2.2.2.2 Address: 192.168.1.2 State: Full Mode:Nbr is Master Priority: 1 DR: None BDR: None MTU: 0 Dead timer due in 100 sec Retrans timer interval: 5 Neighbor is up for 00:00:43 Authentication Sequence: [ 0 ] Router ID: 3.3.3.3 Address: 192.168.1.3 State: Full Mode:Nbr is Master Priority: 1 DR: None BDR: None MTU: 0 Dead timer due in 120 sec Retrans timer interval: 5 Neighbor is up for 00:00:15 Authentication Sequence: [ 0 ] Router ID: 4.4.4.4 Address: 192.168.1.4 State: Full Mode:Nbr is Master Priority: 1 DR: None BDR: None MTU: 0 Dead timer due in 103 sec Retrans timer interval: 5 Neighbor is up for 00:00:15 Authentication Sequence: [ 0 ] 所以说OSPF在点到多点的网络下不选举DR、BDR 接下来将网络类型还原 1ospf network-type broadcast 修改DR优先级，R1：100 R2：50 R4：0 R3：默认 1234567891011121314151617181920212223242526272829[R1-GigabitEthernet0/0/0]display ospf peer OSPF Process 1 with Router ID 1.1.1.1 Neighbors Area 0.0.0.0 interface 192.168.1.1(GigabitEthernet0/0/0)&apos;s neighbors Router ID: 2.2.2.2 Address: 192.168.1.2 State: Full Mode:Nbr is Master Priority: 50 DR: 192.168.1.3 BDR: 192.168.1.1 MTU: 0 Dead timer due in 40 sec Retrans timer interval: 5 Neighbor is up for 00:00:11 Authentication Sequence: [ 0 ] Router ID: 3.3.3.3 Address: 192.168.1.3 State: Full Mode:Nbr is Master Priority: 1 DR: 192.168.1.3 BDR: 192.168.1.1 MTU: 0 Dead timer due in 35 sec Retrans timer interval: 5 Neighbor is up for 00:01:49 Authentication Sequence: [ 0 ] Router ID: 4.4.4.4 Address: 192.168.1.4 State: Full Mode:Nbr is Master Priority: 0 DR: 192.168.1.3 BDR: 192.168.1.1 MTU: 0 Dead timer due in 36 sec Retrans timer interval: 4 Neighbor is up for 00:00:10 Authentication Sequence: [ 0 ] 此时R3是DR，R1是BDR","categories":[{"name":"路由交换","slug":"路由交换","permalink":"https://eeeje.com/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://eeeje.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"华为设备静态路由的配置","slug":"Static","date":"2019-11-01T08:22:10.000Z","updated":"2019-11-18T11:16:13.001Z","comments":true,"path":"2019/11/01/Static/","link":"","permalink":"https://eeeje.com/2019/11/01/Static/","excerpt":"","text":"静态路由一种手动配置的路由方式，各厂商对静态路由的优先级处理不同。 优先级在实验开始之前，首先了解一下华为设备的路由优先级（值越大优先级越小） 协议/种类 优先级 direct 0 OSPF 10 IS-IS 15 Static 60 RIP 100 IBGP 130 OSPF ASE/import 150 EBGP 170 UNKNOWN 255 可以看到华为设备的静态路由优先级是低于ospf与isis的（不算直连路由） 实验设备实验中使用的设备：HUAWEI AR2220 &amp; PC 实验拓扑&amp;规划 实验目的利用默认路由以及配置静态路由使PC1与PC2之间可以互通 实验过程 给PC配置相应的IP 给R1，R2，R3配置对应接口IP（以R1为例） R1： [R1]interface g 0/0/2 [R1-GigabitEthernet0/0/2]ip add 172.10.0.254 24 [R1-GigabitEthernet0/0/2]q [R1]interface g 0/0/0 [R1-GigabitEthernet0/0/0]ip add 10.1.1.1 30 [R1-GigabitEthernet0/0/0]q [R1]q &lt;R1&gt;save现在我们去看路由表（以R1为例）,命令display ip routing-table Routing Tables: Public Destinations : 10 Routes : 10 Destination/Mask Proto Pre Cost Flags NextHop Interface 10.1.1.0/30 Direct 0 0 D 10.1.1.1 GigabitEthernet 0/0/0 10.1.1.1/32 Direct 0 0 D 127.0.0.1 GigabitEthernet 0/0/0 10.1.1.3/32 Direct 0 0 D 127.0.0.1 GigabitEthernet 0/0/0 127.0.0.0/8 Direct 0 0 D 127.0.0.1 InLoopBack0 127.0.0.1/32 Direct 0 0 D 127.0.0.1 InLoopBack0 127.255.255.255/32 Direct 0 0 D 127.0.0.1 InLoopBack0 172.10.0.0/24 Direct 0 0 D 172.10.0.254 GigabitEthernet 0/0/2 172.10.0.254/32 Direct 0 0 D 127.0.0.1 GigabitEthernet 0/0/2 172.10.0.255/32 Direct 0 0 D 127.0.0.1 GigabitEthernet 0/0/2 255.255.255.255/32 Direct 0 0 D 127.0.0.1 InLoopBack0可以看到配置了IP的接口和所在网络都拥有了一条路由，这就是前面提到的直连路由，也就是默认路由 那么，想要实现我们的目标，可以分为两个流程来理解所以，在R1,R2上配置前往PC2网段的路由，在R2,R3上配置前往PC1网段的路由，即可实现网络互通。 配置静态路由 R1： [R1]ip route-static 172.10.10.0 24 GigabitEthernet0/0/0 10.1.1.2 [R1]q &lt;R1&gt;save 查看R1路由表，多了一条这样的路由 172.10.10.0/24 Static 60 0 D 10.1.1.2 GigabitEthernet 0/0/0可以看到优先级,下一跳，出接口等信息 R2： [R2]ip route-static 172.10.10.0 24 GigabitEthernet 0/0/2 10.1.1.6 [R2]q &lt;R1&gt;saveR3： [R3]ip route-static 172.10.0.0 24 GigabitEthernet 0/0/2 10.1.1.5 [R3]q &lt;R1&gt;save验证接下来，由从PC1pingPC2检查网络是否相通 实验结果PC1 与 PC2 互通 浮动静态路由静态路由优先级的一种使用方式，通过配置不同优先级的静态路由实现备用链路Q:静态路由应该也可以通过和其他路由协议（ospf等）之间的优先级差距，实现备用链路吧？ 实验设备HUAWEI AR2220 &amp; PC 实验拓扑&amp;规划 实验目的配置不同优先级的静态路由实现当R2出现故障时，切换为前往R3的路由，保持网络通畅 实验过程相对于上一个实验环境，只多了两条静态路由，所以，直接使用了上一个实验环境进行配置 增加连线，并配置接口ip [R1]interface GigabitEthernet 0/0/1 [R1-GigabitEthernet0/0/1]ip add 10.1.1.9 30 [R1-GigabitEthernet0/0/1]q [R1]q &lt;R1&gt;save​当前的路由路径（PC1pingPC2）: PC&gt;tracert 172.10.10.1 traceroute to 172.10.10.1, 8 hops max (ICMP), press Ctrl+C to stop 1 172.10.0.254 16 ms 15 ms 16 ms 2 10.1.1.2 16 ms 31 ms 15 ms 3 10.1.1.6 32 ms 31 ms 31 ms 4 172.10.10.1 31 ms 32 ms 31 ms配置浮动静态路由（优先级不同的静态路由）R1： [R1]ip route-static 172.10.10.0 24 GigabitEthernet 0/0/1 10.1.1.10 preference 100 &lt;R1&gt;save 优先级配置为100，低于之前配置的缺省值60 此时使用display ip routing-table查看路由表，并没有看到这条路由，猜测是因为没有生效的原因 R3： [R3]ip route-static 172.10.0.0 24 GigabitEthernet 0/0/0 10.1.1.9 preference 100 [R3]q &lt;R3&gt;save#### 验证&amp;排错关闭R2查看R1路由表，发现并没有之前配置的那条优先级为100的路由条目 去翻书，发现需要用这条命令去查display ip routing-table protocol static 结果还是没有，可以看到已配置的路由数量是两条，但是Inactive部分并没有路由条目 把这条备用路由undo了，重新配置！ [R1]undo ip route-static 172.10.10.0 24 10.1.1.10 preference 100 再去用display ip routing-table protocol static看路由表 没有了-重新配置，查看路由表，还是没有！猜测：书上使用的命令并没有配置出接口，我怀疑是这里的问题 重新配置，并且不指定出接口 [R1]ip route-static 172.10.10.0 24 10.1.1.10 preference 100[R1]qsaveR3同理，undo了原来的条目，重新配置 [R3]undo ip route-static 172.10.0.0 24 GigabitEthernet 0/0/0 10.1.1.9 preference100~[R3]ip route-static 172.10.0.0 24 10.1.1.9 preference 100~~ 加了新的物理连接要记得配IP！ 收获：当静态路由的出接口配在未配置IP的接口上时，不会显示在路由表上，这时候，就可以去检查接口IP是否有问题 验证 关闭R2的GE 0/0/0接口 [R2]interface GigabitEthernet 0/0/0 [R2-GigabitEthernet0/0/0]shutdown PC1pingpc2 失败 对R3的GE 0/0/0 0/0/1 0/0/2 同时进行抓包 可以看出来，PC1发出的包到达了PC2，PC2返回的包却被R3发往了优先级为60的R2，R2随之丢弃 当我关闭R2设备时 链路是成立的 负载均衡通过条优先级相同，下一跳不同的静态路由实现负载均衡 修改之前优先级为100的路由[R1]ip route-static 172.10.10.0 24 GigabitEthernet 0/0/1 10.1.1.10 preference 60 完成 总结在配置静态路由时，需要注意整个链路的状态，通常源网络与目的网络中间的每一台设备都要配置对应指向的静态路由，就想接力一样。 ​ ​","categories":[{"name":"路由交换","slug":"路由交换","permalink":"https://eeeje.com/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://eeeje.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"linux中docker的使用笔记","slug":"docker","date":"2019-10-31T11:17:10.000Z","updated":"2019-11-18T11:16:12.680Z","comments":true,"path":"2019/10/31/docker/","link":"","permalink":"https://eeeje.com/2019/10/31/docker/","excerpt":"","text":"容器部分Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口 我这里呢，因为之前搭建带hexo编译环境中的服务与我的nginx冲突，有因为我对linux中http服务的不了解，所以想到了把编译环境搭建在虚拟化容器中办法，阿里云服务器本就是虚拟机，docker则是一个-最佳方案-。最终我选择，宝塔和编译环境 都放入容器。 运行容器docker run --name hexo-v2 -d -it -p 172.17.0.1:2121:22/tcp -p 4000:4000 hexo-v1–name：容器名字hexo-v2：新建的容器名 -d ：后台运行 -it：交互模式运行并分配伪终端 -p：端口映射hexo-v1：使用的镜像名字 进入容器docker exec -it hexo-v2 bash现有容器存为镜像docker commit 容器名称 镜像名称docker镜像的导出和导入显示当前docker中的镜像： docker images镜像列表如下： REPOSITORY TAG IMAGE ID CREATED SIZE pointsift latest 90b2ef439b40 2 weeks ago 12.6GB ubuntu 18.04 735f80812f90 4 weeks ago 83.5MB导出镜像： docker save -o &lt;保存路径&gt; &lt;镜像名称:标签&gt;如把A机 ubuntu:18.04 导出到当前文件夹，则在A机上运行： docker save -o ./ubuntu18.tar ubuntu:18.04 此时，把A机当前文件夹下的ubuntu18.tar拷贝到另一台安装过docker的B机上，在B机上导入镜像： docker load --input ./ubuntu18.tar这样镜像ubuntu:18.04就成功的从A机复制到B机上了 docker容器的导出与导入显示当前docker中运行的容器： docker ps运行的容器列表如下： CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4a02996e83b1 ubuntu:18.04 &quot;/bin/bash&quot; 44 secondsago Up 42 seconds ubuntu18停止容器： docker stop &lt;容器名&gt;如要想要导出ubuntu18,必须先停止（如果ubuntu18没有运行，则不需要执行此步骤）： docker stop ubuntu18如果容器已经停止了，想要查看该容器，可以运行（该命令会显示所有的容器，包括运行的和非运行的）： docker ps -a导出容器： docker export &lt;容器名&gt; &gt; &lt;保存路径&gt;如导在A机中导出容器ubuntu18: docker export ubuntu18 &gt; ./ubuntu18.tar导入容器的命令： docker import &lt;文件路径&gt; &lt;容器名&gt;把A机当前文件夹下的ubuntu18.tar文件拷贝到B机上，在B机上运行： docker import ./ubuntu18.tar ubuntu18启动容器： docker start &lt;容器名&gt;B机上就多了一个名为ubuntu18的容器，但导入的容器还处在未运行的状态，需要启动容器： docker start ubuntu18进入容器： #同一个容器会有相同的界面，如果该容器之前已经运行过，则会直接进入运行容器的界面#该命令通常用于进入后台已经在运行的容器 docker attach &lt;容器名&gt; 或者#同一个容器有不同的界面，进入容器后的界面不会受该容器的其他运行者的影响#一般情况下建议使用该命令 docker exec -it &lt;容器名&gt; &lt;执行指令&gt; 启动容器之后，需要进入容器，可以运行： docker exec -it ubuntu18 /bin/bash这个命令这样也可以 docker exec -it ubuntu18 bash​ 关于端口映射问题目前我发现的最优方案就是把现有容器存为镜像，删除原来的容器（不然会提醒端口被占用）重新建一个，并添加好端口映射 容器开启ssh1、下载centos7的镜像docker pull centos2、查看已有的镜像，将看到有个名为centos的镜像docker images3、基于centos镜像，创建一个名为test的容器docker run -it –name test centos /bin/bash 4、进入容器后，升级并安装ssh服务端和客户端，服务端能让其他主机远程登录本机，客户端能让本机远程登录其他主机yum -y update yum -y install passwd openssl openssh-server openssh-clients5、创建 /var/run/sshd/目录，要不然sshd服务启动会报错mkdir /var/run/sshd/6、编辑sshd的配置文件/etc/ssh/sshd_config，将其中的UsePAM yes改为UsePAM no可以进入sshd_config文件中去修改，也可以使用命令： sed -i &quot;s/UsePAM.*/UsePAM no/g&quot; /etc/ssh/sshd_config7、创建公私密钥，输入命令后，直接按两次enter键确认就行了ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key8、完成上述几步后，可以开启ssh服务了/usr/sbin/sshd -D &amp;此时使用命令ps -ef | grep sshd 便可以看到ssh已经开起来了 输入命令 yum -y install lsof lsof -i:22 //如果在/etc/ssh/sshd_config文件中将端口22修改了，那么填写你修改了的端口9、修改root密码passwd 然后输入设置的密码 10 测试完成1vi /etc/hosts 可以查看到容器的ip 11、配置ssh无密码登录12345ssh-keygen -t rsacd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys 输入完后，这时再输入命令 1ssh localhost 发现并不用在输入命令了：）。 ssh无密码登录可用hadoop集群中master主节点无密码登录从节点。 阿里云ssh欢迎语阿里云自带的欢迎语太丑了于是自己找了找路径在/etc/motd这个文件里里面的内容改了就可以 日常懒得截图镜像/容器部分转载自：https://www.jianshu.com/p/4e862a2a2d03SSH部分转载自：https://blog.csdn.net/u013140345/article/details/79777311","categories":[{"name":"运维","slug":"运维","permalink":"https://eeeje.com/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://eeeje.com/tags/linux/"}]},{"title":"linux中安装hexo编译博客","slug":"hexo","date":"2019-10-28T17:41:10.000Z","updated":"2019-11-18T11:16:12.750Z","comments":true,"path":"2019/10/29/hexo/","link":"","permalink":"https://eeeje.com/2019/10/29/hexo/","excerpt":"","text":"背景几天前就看到服务器要到期了，没去管他，结果给忘了，今天凌晨过期了，这台阿里云华东2（上海）的机器也用了快2年了，物理位置在上海让我这个强迫症很不舒服，而且40G的盘都用了30G了（反正就是给自己各种不嫌麻烦的借口），看到新出的学生机有可以购买在华东1（杭州）就果断释放了原来的服务器，新购于杭州节点之前用宝塔做了备份策略，所以数据都储存在我的OSS里面前几天用hexo在github上发布了博客，但是只能在我自己的电脑上进行编译，有一些局限，所以先在这台服务器上安装hexo用来在云端编译博客。顺便发现了个BUG,阿里云学生机在认证期限内，好像可以不限次数的续费，我准备存点生活费续他个十年八年的试试。废话不多说 发布的时候发现博客园的Markdown预格式化文本真的很烦，有些代码直接显示文本了安装连接服务器管你cmd、xshell、hyper、putty还是什么的，连的上就完事 安装node.js这是个JavaScript运行环境 这一步建议在特定目录下操作 没有linux基础请跟我做 mkdir /soft mkdir /soft/hexo cd /soft/hexo 从官网下载linux版本的node.js 或者直接采用wget方式下载 这里使用wget下载 wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz​ 把他解压了 tar xf node-v10.9.0-linux-x64.tar.xz 解压以后测试是否安装成功 移动到目录 cd node-v10.9.0-linux-x64/执行命令 ./bin/node -v // 如果出现版本号，说明安装成功修改node-v10.9.0-linux-x64文件夹名字为nodejs cd .. mv node-v10.9.0-linux-x64 nodejs 设置软连接 ln -s /soft/hexo/nodejs/bin/node /usr/local/bin/node ln -s /soft/hexo/nodejs/bin/npm /usr/local/bin/npmgit安装 安装依赖包 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel yum install gcc perl-ExtUtils-MakeMaker通过命令 git --version 可以看到，Git 当前的版本号为 1.8.3.1，太过于陈旧，所以需要先把它移除了。 卸载旧版本的 Git yum remove git然后移动到/usr/local/ cd /usr/local/ 下载并解压 wget https://github.com/git/git/archive/v2.9.2.tar.gz tar -zxvf v2.9.2.tar.gz // 解压 mv git-2.9.2 git //重命名 编译安装 cd git // 进入文件夹 make prefix=/usr/local/git all // 编译源码 make prefix=/usr/local/git install // 安装至 /usr/local/git 路径编译时，由机器配置决定速度，请耐心等待。 打开环境变量配置文件 vim /etc/profile在文件底部添加以下配置。 PATH=$PATH:/usr/local/git/bin // git 的目录 export PATH两个语句都要加上 刷新环境变量 source /etc/profile最后再使用 git --version 查看版本号，已经为 2.9.2 安装hexonpm install hexo-cli -g搭建博客基础 先把hexo命令添加到全局：hexo在nodejs的lib/node_modules/hexo-cli/bin 可以找到hexo命令方式是采用软连接 ln -s /soft/hexo/nodejs/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo 部署hexo博客环境：这个可以放在nodejs外面，方便打开cd 到和nodejs一个目录下（我是放在根目录下的）然后: mkdir hexo cd hexo hexo init //会自动把资源文件下载好解释一下node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 搭桥到github 创建一个repo，名称为yourname.github.io, 其中yourname是github名称（我已经有了，就不截图了） 下面的每一步，要把yourname换为自己的github名字，youremail换为自己的github邮箱 配置github账户信息 git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot;​创建SSH 输入：ssh-keygen -t rsa -C &quot;youremail&quot;，生成ssh 下面提示地方一路回车就可以 然后去找生成的sshkey cd ~/.ssh cat id_rsa.pub把回显的那些字符复制出来 在github的setting中找到SSH and GPG keys，点击 New SSH key title随便取，key就填刚刚那一段ssh 在gitbash中验证是否添加成功：ssh -T git@github.com 一步之遥 用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)注意YourgithubName改为你的 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master这样子需要每次都输入密码，如果不想每次输入密码的话把https://github.com/YourgithubName/YourgithubName.github.io.git改为git@github.com:YourgithubName/YourgithubName.github.io.git 回到gitbash中，进入你的blog目录，分别执行以下命令 hexo clean hexo server​ 启动测试环境 hexo s 输入 yourip:4000/即可访问页面 如果是服务器，我的是阿里云服务器，需要配置安全组打开4000端口，这样就可以访问了或者linux虚拟机，需要测试内外能否正常通信每次编辑好都执行下面的命令进行上传 hexo clean hexo g //编译 hexo d //上传 这样，基本的hexo环境就搭建好了。","categories":[{"name":"运维","slug":"运维","permalink":"https://eeeje.com/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://eeeje.com/tags/linux/"}]},{"title":"TCP/UDP","slug":"tcp","date":"2019-10-28T11:41:10.000Z","updated":"2019-11-18T11:16:13.029Z","comments":true,"path":"2019/10/28/tcp/","link":"","permalink":"https://eeeje.com/2019/10/28/tcp/","excerpt":"","text":"传输协议之-TCP/UDP对比TCP 可靠 面向连接-类似打电话/收到扣1 但是效率比较低UDP 不可靠的 面向无连接-类似群聊 效率高eg：QQ传文件-TCP（保证文件完整），发消息-UDP 数据包结构 TCPtcp三次握手 甲：你是小王？乙：是的，我是小王，你是老李吗？甲：是的我是老李 流程：主机1发送SYNseq=0，ctl=SYN（seq标记位，序列号） –&gt;主机2收到SYN，发送SYN及ACK（确认号：收到的序列号+1）seq=0（序列号）,ack=1,ctl=SYN(同步位),ACK–—&gt;主机1收到STN及ACK，Establishedseq=1 ack=1 ctl=ACK抓包实例 拓展：安全方向-SYN Flood（洪水）攻击是ddos的主要方式，通过僵尸网络发送大量的第一个SYN报文，并不回复第二个包。 tcp会话确认 所有的包都要确认，只有第一个包是没有确认号的 最终的确认号就是数据的大小主机1 seq=1 ack=1 |Data（9字节）–&gt;主机2 seq=1 ack=10 |Data（20字节）“ack=10理解为‘你可以发送序列号为10的数据包了’”–&gt;主机1 seq=10 ack=21 |Data（12字节）–&gt;主机2 seq=21 ack=22 |Data（n字节） 确认号就是前一个包的序列号+数据 不是每一个包都会确认，主机2连续发包时主机1多个包回复一个确认。 理解：乙给甲说了很多句话，甲回复乙，前几句话我都听到了，然后乙接着讲话。抓包实例（从阿里云oss下载文件） tcp会话的拥塞和流量控制 “你说太快了，慢点”“你说太慢了，快点” 每个数据包有个window字段 win 窗口大小决定了在收到确认前可以发送的字节数。抓包实例（下载文件）实际抓包过程中发现，服务器发过来的包要远超过主机确认包中的窗口大小。Q：why？ tcp会话的终止-四次挥手 小王：我要挂了老李：好的，再见老李：我也挂了小王：好的，再见 终止位FIN，位于flages的最后一个字节并不一定是所有的终止都有四次握手比如我的多次尝试都没有抓到四次握手的终止会话可以看到主机发出了带FIN的包，服务器确认了上一个包并带了FIN标识，主机确认了这个包后连接被关闭。另外，我在抓包时发现了另外一个现象：可以看到服务器发出一个带有FIN标识的包后主机先返回了一个确认包，又连续的发出了一个带有急迫标识的包与一个带有重置标识的包，服务器返回了重置的包，连接重新建立。 UDPUDP是一种面向无连接的传输层协议，传输可靠性没有保证udp不提供重传记住，占用资源小，处理效率高一些时延敏感的流量，如语音、视频、游戏等，通常使用udp作为传输层协议eg：看视频卡顿，失真，玩游戏卡顿 总结对比 传输控制协议（TCP） 用户数据协议（UDP） 面向连接 无连接 可靠传输 尽力而为的传输 支持流控及窗口机制 无流控及窗口机制 HTTP、FTP等 TFTP、DNS、DHCP等","categories":[{"name":"路由交换","slug":"路由交换","permalink":"https://eeeje.com/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://eeeje.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"1027笔记","slug":"1027","date":"2019-10-27T05:57:10.000Z","updated":"2019-11-18T11:16:12.361Z","comments":true,"path":"2019/10/27/1027/","link":"","permalink":"https://eeeje.com/2019/10/27/1027/","excerpt":"","text":"路由器选路的方式依靠路由表 路由器选路 先匹配策略路由，如果没有再去查路由表路由表里面一定存放的是最优的路由路由表会最客观显示出当前的路由情况 问题处理：名词查询，理解连接起来 路由表static rip ospf isis bgp等都是三层协议=路由协议direct 直连路由pre 优先级越小越优 每家厂商的优先级都是不同的 华为： Direct OSPF Static RIP 0 10 60 100 cost 拥挤程度 带宽 开销 参考系很多ospf带宽·rip·跳数 nexthop 下一跳interface 出接口（对自己来言）每条就是一个路由条目 看OSPF 静态路由出接口、下一跳都进行配置 任务Hcna实验指南静态路由实验 拓扑截图OSPF实验","categories":[{"name":"路由交换","slug":"路由交换","permalink":"https://eeeje.com/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://eeeje.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"记录下京东备件库购物经历","slug":"shopping","date":"2019-10-23T14:48:10.000Z","updated":"2019-11-18T11:16:12.903Z","comments":true,"path":"2019/10/23/shopping/","link":"","permalink":"https://eeeje.com/2019/10/23/shopping/","excerpt":"","text":"我的第一篇正式博客记录一次京东备件库购物经历博客基于hexo编写，托管于Github，图片使用阿里oss托管前几天偶尔在张大妈看到很多备件库晒单帖子，好多人买到了合自己心意价格又划算的东西，就很好奇的去看了看备件库（京东搜索备件库）接着就有了这个购物经历 先介绍下京东备件库这是京东的官方介绍 首先来讲渠道从来源上来讲，备件库的商品是来自自营店，那么产品从渠道上来讲是没有问题的，虽然说官方给了好几个来源，但是我觉得最主要的途径是来自于“7天无理由退换货”的政策 其次说成色官方给出了3个标准，分别是99新 9成新 7成新 备件库一般都会做完检测评完级再进行入库，99新和9成新一般都是未拆封/拆封未使用/轻度使用的东西，我主要说一下7成新 ，7成新最引人注意的是价格足够便宜，而从成色来讲，可以分为三种产品较差 包装较差 产品,包装都差 于是乎，在备件库“7天无理由退货”的蛊惑下，我买了两款七成新的外设。 开箱我买的两款外设分别是罗技 G903双模游戏鼠标和雷蛇 雷霆齿鲸V2 USB版 罗技 G903新品售价799元，入手366元 这款鼠标真的是眼馋了很久，奈何799的价格让我望而却步 包装 备件库专用的白色大标签，其实我看到包装的时候是比较慌的，包装还行，中规中矩，产品会不会成色不行 正面 这是我用了两天拍的照片，正面没有任何问题，中间有一点灰尘，吹一吹就掉了 背面 看来被评为7成新的原因就在这里了，滑片那里明显可以看到许多划痕，基本可以确定上一个使用者是在没有鼠标垫的场景下进行使用的 总体来说，以366的几个买到这样的一只鼠标还是很划算的，因为我用的大鼠标垫，下面的划痕基本对我使用没有造成影响，下载了驱动，测试了一番后美滋滋的用起来了（无级滚轮是真的爽）。关于G903的使用等可以去看其他外设博主的测评，这里就不进行阐述了 雷蛇 雷霆齿鲸V2 USB版新品售价469元 到手150元 买耳机的原因呢，是因为寝室有一位室友，玩游戏时特别的“兴奋”，简单形容一下：.，刚好我又报了HCIE的网络课程，所以我迫切的需要一支头戴式耳机，让我可以在寝室里活下去。 包装 耳机的包装拿到手后让人害怕，塑料变形，宽胶带粘起来的盒子 产品 拿出耳机后发现，竟然是新的！（心里开了花），检查了下外观，没有任何使用痕迹，接着就是二手头戴耳机成色检测法： 闻，因为耳机经过长时间使用后，头部区域因为出汗或者洗发水的缘故，或多或少的会有一些味道留在上面，这时候就可以通过味道的深浅确定使用的时间长短，嗯~是清新的塑料味，等等？塑料味？hhhhh运气正好，撸到了准全新，看来这就是我前面提到的包装较差 细节150块买到这样一款准全新耳机真的是赚到了，40mm钕磁铁驱动单元、可拆卸麦克风，终于可以适量的减轻耳朵的压力了 总结如果你不介意二手的话，相对于咸鱼来路不是很清晰的东西，京东备件库也是一个不错的选择，99新和9成新基本可以考虑入手，价格相对来说还算美丽，就算不满意也有“七天无理由退货”的政策让你反悔，至于7成新，刚需的朋友可以尝试一下，毕竟价格太诱人，也有“7天”政策做保障，最后留一句：备件库看看就好了，千万别去夺宝岛拍东西，被人称作“夺命岛”是有原因的。","categories":[{"name":"购物","slug":"购物","permalink":"https://eeeje.com/categories/%E8%B4%AD%E7%89%A9/"}],"tags":[{"name":"购物","slug":"购物","permalink":"https://eeeje.com/tags/%E8%B4%AD%E7%89%A9/"}]}]}